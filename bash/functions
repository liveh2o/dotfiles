#!bash
#
# Changing directory to code project
function c { cd $PROJECT_PATH/$1; }

# Switch to default Ruby
function drb {
  rbenv shell default
}

# Switch to latest JRuby
function jrb {
  if [ -z "$1" ]
  then
    rbenv shell jruby
  else
    rbenv shell jruby-$1
  fi
}

# Switch to Ruby version specified in the current directory
function localrb {
  rbenv shell --unset
}

# Switch to latest Ruby
function rb {
  if [ -z "$1" ]
  then
    rbenv shell ruby
  else
    rbenv shell $1
  fi
}

# Changing directory to code project
function c { cd $PROJECT_PATH/$1; }

# Search through the whole codebase
function hunt { find $PROJECT_PATH -type f -name "$1" -not -path "*vendor*" -print0 | xargs -0 ack -Q $2; }

# Find commit diffs between two branches
function cherry {
  __git_repo_check

  local upstream=${1:-'main'}
  local head=${2:-'HEAD'}

  git cherry -v $upstream $head
}

# Push a branch to origin
function gpush {
  git push origin $(__git_current_branch)
}

# Synchronize remote branches
function gsync {
  case $1 in
    '-A' | '--all')
      local current_directory=$PWD

      for repo in $(ls -d */)
      do
        cd $current_directory/$repo
        __git_sync_remote_branches
      done

      cd $current_directory;;
    *)
      __git_sync_remote_branches;;
  esac
}

# Hard-reset branches back to origin
function hardreset {
  __git_status_check

  git fetch origin

  local startbranch=$(__git_current_branch)

  for branch in $(__git_branches)
  do
    git rev-parse origin/$branch &> /dev/null
    if [[ $? -eq 0 ]]
    then
      currev=$(git rev-parse $branch)
      syncrev=$(git rev-parse origin/$branch)
      if [[ $currev != $syncrev ]]
      then
        echo " > Resetting branch $branch to origin/$branch"
        git checkout $branch
        git reset origin/$branch --hard
      fi
    else
      echo " ! Branch $branch doesn't have an origin"
    fi
  done

  __git_checkout_unless_current $startbranch

  echo "Local branches have been reset."
}

# Interactively rebase the current git branch
function rebase {
  __git_status_check
  git rebase -i HEAD~$1
}

# Prompt setup
function parse_git_branch { echo `__git_ps1`; }

function __git_branches {
  git branch | sed -e 's|* ||g' -e 's|^[ ]*||'
}

function __git_checkout_unless_current {
  [ $1 ] && [ $1 != $(__git_current_branch) ] && git checkout $1
}

function __git_current_branch {
  __git_repo_check

  git branch | grep '*' | sed -e 's/* //'
}

function __git_repo_check {
  [ -d '.git' ] || (echo "Not a git repo." && return)
}

function __git_status_check {
  __git_repo_check

  git status -s
  git diff-index --quiet HEAD --

  [ $? -ne 0 ] && echo "You have local changes that haven't been committed!" && return
}

# Pull all changes from origin
function __git_sync_remote_branches {
  __git_status_check

  git remote prune origin
  git fetch origin

  local startbranch=$(__git_current_branch)

  for branch in $(__git_branches)
  do
    git rev-parse origin/$branch &> /dev/null

    if [[ $? -eq 0 ]]
    then
      local currev=$(git rev-parse $branch)
      local syncrev=$(git rev-parse origin/$branch)

      if [[ $currev != $syncrev ]]
      then
        echo " > Synchronizing branch $branch"
        git checkout $branch
        git merge origin/$branch
      fi
    else
      echo " ! Branch $branch doesn't have an origin"
    fi
  done

  __git_checkout_unless_current $startbranch

  echo "Local branches are in sync."
}
